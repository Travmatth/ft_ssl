/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   scrypt.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tmatthew <tmatthew@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2018/08/15 19:22:59 by tmatthew          #+#    #+#             */
/*   Updated: 2018/09/15 21:38:02 by tmatthew         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/ft_ssl.h"

void	scrypt_block_mix(uint32_t block_size
	, uint32_t *blocks
	, uint32_t *mixed)
{
	uint32_t	internal[16];
	uint32_t	i;

	block_size *= 2;
	ft_memmove((void*)internal, &blocks[(block_size - 1) * 16], 16 * 4);
	i = 0;
	while (i < block_size)
	{
		xor_word(16, &blocks[i * 16], internal);
		salsa_core(internal, internal, 8);
		ft_memmove((void*)&mixed[i * 8], (void*)internal, 16 * 4);
		xor_word(16, &blocks[(i + 1) * 16], internal);
		salsa_core(internal, internal, 8);
		ft_memmove((void*)&mixed[i * 8 + block_size * 8]
			, (void*)internal
			, 16 * 4);
		i += 2;
	}
}

/*
** The scrypt_ro_mix Algorithm
**    The scrypt_ro_mix algorithm is the same as the ROMix algorithm
**    described in [SCRYPT] but with scrypt_block_mix used as the hash
**    function H and the Integerify function explained inline.
**    Algorithm scrypt_ro_mix
** Input:
** r       Block size parameter.
** B       Input octet vector of length 128 * r octets.
** N       CPU/Memory cost parameter, must be larger than 1,
**         a power of 2, and less than 2^(128 * r / 8).
** Output:
** B’      Output octet vector of length 128 * r octets.
*/

void	scrypt_ro_mix(unsigned block_size
	, unsigned cost_param
	, uint32_t *block_tmp
	, uint32_t *cost_tmp
	, unsigned char *blocks)
{
	uint32_t	len;
	uint32_t	i;
	uint32_t	*internal_tmp;

	i = 0;
	len = block_size * 32;
	internal_tmp = &cost_tmp[len];
	to_little_endian(blocks, cost_tmp, len);
	while (i < cost_param)
	{
		ft_memmove(&block_tmp[i * len], cost_tmp, len * 4);
		scrypt_block_mix(block_size, cost_tmp, internal_tmp);
		ft_memmove(&block_tmp[(i + 1) * len], internal_tmp, len * 4);
		scrypt_block_mix(block_size, internal_tmp, cost_tmp);
		i += 2;
	}
	i = 0;
	while (i < cost_param)
	{
		xor_word(len, &block_tmp[(cost_tmp[len - 16] & (cost_param - 1)) * len], cost_tmp);
		scrypt_block_mix(block_size, cost_tmp, internal_tmp);
		xor_word(len, &block_tmp[(internal_tmp[len - 16] & (cost_param - 1)) * len], internal_tmp);
		scrypt_block_mix(block_size, internal_tmp, cost_tmp);
		i += 2;
	}
	to_big_endian(blocks, cost_tmp, len);
}

/*
** http://www.tarsnap.com/scrypt/scrypt.pdf
** P passphrase, an octet string
** S Salt, an octet string
** r blockSize specifies the block size.
** N CPU/Memory cost param, must be larger than 1, a power of 2, and less than 2^(128 * r / 8).
** p parallelization param, a positive integer less than or equal to ((2^32-1) * hLen) / MFLen
** 		where hLen is 32 and MFlen is 128 * r.
** dkLen, intended output length in octets of the derived key;
**      a positive integer less than or equal to (2^32 - 1) * hLen where hLen is 32.
** outputs: DK, derived key of length dkLen
**
** uses pbkdf2 with pseudorandom func PRF to generate p blocks
** of length MFLen octets from the provided password/salt
** (B0 . . . Bp−1) ← PBKDF2_PRF (P, S, 1, p · MF Len)
** block_len = 128 * block_size;
** Need to pull these inits out into separate function
** if allocs fail, need to free prev
** independently mixed using mixing func scrypt_ro_mix
** final output is generated by applying pbkdf2 again,
** using well-mixed blocks as salt. 
**
** 3: s | blocks 
** 4: s_len | i * 128 * opts->block_size
** 5: blocks | key
** 6: 128 * opts->block_size * opts->parallelization_param | key_len
** 7: opts->rounds == 1
** pbkdf2(1, 2, 3, 4, 5, 6, 7);
** pbkdf2(1, 2, 3, 4, 5, 6, 7);
*/

void	scrypt(t_desctx *ctx, t_scrypt *opts)
{
	size_t			i;
	unsigned char	*blocks;
	uint32_t		*block_tmp;
	uint32_t		*cost_tmp;
	uint32_t		rb;

	rb = opts->block_size << 7;
	verify_scrypt_params(opts->parallelization_param, opts->block_size, opts->cost_param); 
	blocks = ft_memalloc(opts->parallelization_param * rb);
	block_tmp = ft_memalloc(opts->cost_param * rb);
	cost_tmp = ft_memalloc(2 * rb);
	pbkdf2(ctx->password, ctx->p_len, ctx->salt, ctx->s_len, blocks, 128 * opts->block_size * opts->parallelization_param, 1);

	i = 0;
	while (i < opts->parallelization_param)
	{
		scrypt_ro_mix(opts->block_size, opts->cost_param, block_tmp, cost_tmp, &blocks[i * 128 * opts->block_size]);
		i += 1;
	}
	pbkdf2(ctx->password, ctx->p_len, blocks, i * 128 * opts->block_size, key, key_len, 1);
	free(blocks);
	free(block_tmp);
	free(cost_tmp);
}

void	configure_key(t_desctx *ctx)
{
}